---
css: [css/styles.css]
notesSeparator: "! notas !"
enableChalkboard: false
---

#### Rust para Principiantes #2:
#### Mutabilidad y Tipos de Datos

! notas !
Buenas, soy Cargo Learn, bienvenido al segundo video de Rust para Principiantes, el curso donde aprender√°s a programar desde cero.

En este video ampliaremos los conceptos del anterior viendo como cambiar el valor de las variables y sus tipos de datos principales.

---
#### ¬øNo se supon√≠a que las variables pod√≠an variar?

! notas !
¬øQu√© es eso de mutabilidad? ¬øLas variables no eran‚Ä¶ variables?

Este es un concepto especial en Rust, donde son inmutables por defecto, o sea, que no pueden cambiar.

Por ejemplo, si intentamos modificar el valor de una, nos encontramos con el siguiente error:

---
<div class="free">

```rust
let variable = 5;
variable = 6;
println!("{variable}");


error[E0384]: no se puede asignar dos veces a la variable inmutable `variable`
--> src/main.rs
    
    let variable = 5;
        --------
        |
        primera asignaci√≥n a `variable`
        ayuda: considera hacer que esta asignaci√≥n sea mutable: `mut variable`
  variable = 6;
  ^^^^^^^^^^^^ no se puede asignar dos veces a una variable inmutable
```

</div>

! notas !
Hm‚Ä¶ El compilador nos recomienda que pongamos `mut` delante del nombre de la variable, vamos a hacerle caso:

---
```rust
let mut variable = 5;
variable = 6;
println!("{variable}"); // 6
```

! notas !
Perfecto, ¬°ahora no hay ning√∫n error!
Y efectivamente, si imprimimos el valor de la variable despu√©s de reasignar, vemos que da seis.

Imagino que ahora se te estar√° pasando por la cabeza‚Ä¶

---
#### ¬øPor qu√© tengo que marcar las variables que quiero cambiar?

! notas !
¬øPor qu√© tengo que marcar las variables que quiero cambiar?

Pues bien, Rust es un lenguaje que prefiere ser lo m√°s expl√≠cito posible,
dado que muchos errores en programas vienen de cosas que se suponen.

Para ahorrarse este tipo de problemas, Rust obliga al programador a declarar sus intenciones, haciendo el c√≥digo mucho m√°s sencillo de entender.

---
```rust
let DNI       = 53725777;
let letra_DNI = 'Z';
let nombre    = "Pedro";
let mut saldo = 100.0;
```

! notas !
Por ejemplo, supongamos que somos una tienda online y queremos registrar a un usuario.

De este usuario queremos guardarnos el DNI, la letra del DNI, el nombre y su saldo disponible.

Evidentemente, tanto el DNI como el nombre de la persona no pueden cambiar, as√≠ que los haremos inmutables.
En cambio, el saldo ir√° cambiando a medida que el usuario compre cosas, as√≠ que lo haremos mutable.

---
#### ¬øQu√© son esas comillas de la letra del DNI?

! notas !

Si eres un poco observador, habr√°s visto que en el ejemplo anterior hay dos tipos de notaciones que no he explicado: las comillas simples y el punto del saldo.

Antes de explicar el porqu√© de ellas, vamos a ver otro mensaje de error.
¬øQu√© pasar√° si intento asignar un texto al saldo del usuario?

---
<div class="free">

```rust
let DNI       = 53725777;
let letra_DNI = 'Z';
let nombre    = "Pedro";
let mut saldo = 100.0;

saldo = "patatas";
```
#### Pues‚Ä¶ Que Rust se queja bastante
```
--> src/main.rs
    let mut saldo = 100.0;
    
    saldo = "patatas";
--          ^^^^^^^^^ se esperaba un n√∫mero decimal, se encontr√≥ un texto
```

</div>

! notas !
Pues‚Ä¶ Que Rust se queja bastante.

Pero parece que se queja por una raz√≥n, dice que esperaba que el valor que queremos asignar a `saldo` fuera un n√∫mero decimal, pero que, en cambio, ha sido un texto.

Eso, amigo m√≠o, son los tipos de datos en acci√≥n.

---
#### Es muy claro y lo entiende todo el mundo: 
#### Un vaso es un vaso y un n√∫mero es un n√∫mero

! notas !
En perspectiva, puede parecer un poco absurdo, ¬øpor qu√© querr√≠a yo asignar ‚Äúpatatas‚Äù a un saldo?

Pues, aunque no lo parezca, existen lenguajes que te permiten hacerlo, y lo anuncian como uno de sus fuertes.

Estos lenguajes se denominan Din√°micos, indicando que el valor de cada variable es din√°mico, puede ser el que quieras.

En cambio, Rust es un lenguaje Est√°tico, significando que proh√≠be que trates todas las variables del mismo modo, crea una separaci√≥n de conceptos.

Volvamos al ejemplo de antes, pero ahora hagamos expl√≠cito el tipo de cada variable.

---
```rust
let       DNI: u64  = 53725777;
let letra_DNI: char = 'Z';
let    nombre: &str = "Pedro";
let mut saldo: f64  = 100.0;
```
! notas !
Eh‚Ä¶ Acaban de aparecer muchos nombres extra√±os, ¬øqu√© es un 'u' sesenta-y-cuatro? ¬øY ese ampersand str?

Vamos a diseccionar cada l√≠nea:

---
```rust[1]
let       DNI: u64  = 53725777;
let letra_DNI: char = 'Z';
let    nombre: &str = "Pedro";
let mut saldo: f64  = 100.0;
```
#### Unsigned 64-bit integer
! notas !
El tipo del DNI, indicado por el texto de despu√©s de los dos puntos, es de n√∫mero natural, pero m√°s espec√≠ficamente, como veis en pantalla, de un n√∫mero entero sin signo, de 64 bits.

Siendo un n√∫mero entero, decimos que no le podemos asignar un valor decimal, por ejemplo 6.5, y sin signo que no puede ser negativo.

Esto para el DNI nos va genial, porque nos libramos de tener que lidiar con valores incorrectos. 

---
| TIPO |           | VALORES POSIBLES               |
|:----:| --------- |:------------------------------ |
|  u8  | $2^8$     | [0, 256]                        |
| u16  | $2^{16}$  | [0, 65.536]                     |
| u32  | $2^{32}$  | [0, 4.294.967.296]              |
| u64  | $2^{64}$  | [0, 18.446.744.073.709.551.616] |
| u128 | $2^{128}$ | [0, UN N√öMERO ENORME]           |

! notas !

Vamos a hacer un repaso r√°pido de qu√© significa lo de ‚Äú64 bits‚Äù.
Como ya viste en el v√≠deo anterior, los ordenadores solo entienden de unos y ceros.
Debido a esto, cada dato ocupa un cierto n√∫mero de unos y ceros, llamados bits. Cuantos m√°s bits tengas disponibles, m√°s grande podr√° ser el dato que quieras guardar.

Adem√°s, el cambio es bastante radical, ya que con ocho bits solo puedes representar hasta doscientos-cincuenta-y-seis, pero, en cambio, con diecis√©is bits pasas a sesenta-y-cinco mil.

Rust por defecto usa n√∫meros de treinta-y-dos bits, pero te recomiendo que experimentes y cambies el tipo seg√∫n lo que te interese.

---
| TIPO |           | VALORES POSIBLES                                        |
|:----:|:---------:|:------------------------------------------------------- |
|  i8  |   $2^8$   | [-128, 127]                                             |
| i16  | $2^{16}$  | [-32.768, 32.767]                                       |
| i32  | $2^{32}$  | [-2.147.483.648, 2.147.483.647]                         |
| i64  | $2^{64}$  | [-9.223.372.036.854.775.808, 9.223.372.036.854.775.807] |
| i128 | $2^{128}$ | [UN N√öMERO MUY PEQUE√ëO, UN N√öMERO ENORME]               |



! notas !

Para los n√∫meros negativos funciona exactamente igual, y se indica cambiando la ‚Äúu‚Äù por una ‚Äúi‚Äù, de ‚Äúinteger‚Äù.

Como ahora representamos tanto n√∫meros positivos como negativos, el valor m√°ximo se ve reducido a la mitad, pero a cambio conseguimos que el m√≠nimo sea pr√°cticamente el mismo pero con signo invertido.

Si est√°s m√°s interesado de por qu√© los n√∫meros son as√≠, puedes ir al v√≠deo de ‚Äú¬øQu√© es el sistema binario?‚Äù, donde explico como los ordenadores interpretan los bits. 

---
```rust[2]
let       DNI: u64  = 53725777;
let letra_DNI: char = 'Z';
let    nombre: &str = "Pedro";
let mut saldo: f64  = 100.0;
```
#### Character

! notas !
Continuemos con el ejemplo.
Ahora toca ver qu√© significan las comillas simples y el tipo ‚Äúchar‚Äù.

Una variable de tipo ‚Äúchar‚Äù, como ya puedes haber deducido, contiene un car√°cter.

¬øY qu√© es un car√°cter?

---
| "Hola üòÑ" | ‚Üí   | 'H' | 'o' | 'l' | 'a' | 'üòÑ' |
| --------- | --- | --- | --- | --- | --- | ---- |
|           |     |     |     |     |     |      |

! notas !

Simplificando un poco, podr√≠amos definirlo como cada parte que forma un texto.

Por ejemplo, ‚ÄúHola carita feliz‚Äù est√° compuesto por los caracteres hache, o, ele, a y la carita feliz.

---
```rust[3]
let       DNI: u64  = 53725777;
let letra_DNI: char = 'Z';
let    nombre: &str = "Pedro";
let mut saldo: f64  = 100.0;
```
#### String Slice

! notas !
Una vez introducidos los caracteres, podemos ir a la tercera l√≠nea, donde vemos el extra√±o str.

Intuitivamente, podemos suponer que es un tipo que guarda texto, ya que tiene el nombre ‚ÄúPedro‚Äù asignado.

Pero‚Ä¶ ¬øPor qu√© tiene este nombre? ¬øQu√© es un string?

---
#### 'P' - 'E' - 'D' - 'R' - 'O'

! notas !
Pues bien, podr√≠amos entender el t√©rmino string como un hilo que une distintos caracteres, formando un texto.

Siendo un poco m√°s t√©cnicos, se le podr√≠a llamar secuencia de caracteres, ya que es b√°sicamente eso, una lista de s√≠mbolos.

---
#### ¬øY el ampersand?
#### ¬øY eso de ‚Äúslice‚Äù?

! notas !
¬øY el ampersand? ¬øY eso de "slice‚Äù?
Bueno‚Ä¶ Estas preguntas me las reservo para el pr√≥ximo v√≠deo, puesto que son conceptos un poco m√°s avanzados.
De momento qu√©date con que cuando escribes texto entre comillas dobles est√°s creando un string, y con comillas simples un car√°cter.

---
```rust[4]
let       DNI: u64  = 53725777;
let letra_DNI: char = 'Z';
let    nombre: &str = "Pedro";
let mut saldo: f64  = 100.0;
```
#### 64-bit floating point number

! notas !
¬°Finalmente hemos llegado a la √∫ltima l√≠nea!

Como con el string, es f√°cil ver intuitivamente para qu√© sirve este tipo, n√∫meros decimales.

Lo que es m√°s complicado es deducir el nombre, ¬øN√∫mero de punto flotante? ¬øQu√©?

---
#### Personas muy listas hacen cosas

! notas !
En muy resumidas cuentas, es un sistema que permite representar n√∫meros decimales en binario, con un rango inmenso de valores, pero que se basa en aproximaciones.

Le llamamos de ‚Äúpunto flotante‚Äù porque la precisi√≥n de los decimales cambia seg√∫n el n√∫mero, como si el punto flotara entre los d√≠gitos.

Har√© un v√≠deo explicando esto en detalle, as√≠ que si te interesa agradecer√≠a mucho que te subscribieras al canal.

---
#### Para que practiques un poco

! notas !
Ahora que ya he introducido bastante, podemos empezar con algunos ejercicios.

En la descripci√≥n tendr√°s un enlace a dos Playground, uno con los enunciados de los ejercicios y el otro con las soluciones.

---
#### ¬°Hasta el siguiente v√≠deo!
! notas !
Y bien, ¬°muchas gracias por haber llegado hasta aqu√≠!

Como siempre, en la descripci√≥n tienes el c√≥digo fuente de esta presentaci√≥n, juntamente con un Playground con los ejemplos que han ido saliendo.

Adem√°s, tambi√©n puedes encontrar las secciones del libro oficial de Rust que hablan sobre los conceptos del video, por si quieres expandir tus conocimientos.

¬°Hasta el siguiente v√≠deo!

---
# Enlaces
Playground video: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f3b222fc3038cb795a60742a5f81f17e

Playground ejercicios: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d74feb46ab863a62dbbb1d72bb00d8d2

Playground soluciones:https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c8a24bfac6310f18b957bd5acd23bc75

Variables y mutabilidad: https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html

Tipos Enteros: https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types

Tipos Decimales (punto flotante): https://doc.rust-lang.org/book/ch03-02-data-types.html#floating-point-types

Tipo Car√°cter: https://doc.rust-lang.org/book/ch03-02-data-types.html#the-character-type

Tipo String Slice (&str): https://doc.rust-lang.org/book/ch04-03-slices.html?highlight=str#string-slices

---
# Descripci√≥n del v√≠deo
¬øQuieres aprender a programar? 
¬øHas o√≠do hablar de Rust, pero piensas que ser√° demasiado dif√≠cil? 
En Cargo Learn te demostramos que es posible aprender Rust como primer lenguaje. 

Esta es la segunda parte del curso ‚ÄúRust para Principiantes‚Äù, donde ampliaremos los conceptos del anterior y presentaremos los tipos de datos.

Enlaces:
Playground video: https://tinyurl.com/cargolearn-playground-2
Playground ejercicios: https://tinyurl.com/cargolearn-playground-2-ej
Playground soluciones:https://tinyurl.com/cargolearn-playground-2-sol

Variables y mutabilidad: https://tinyurl.com/cargolearn-variables
Tipos Enteros: https://tinyurl.com/cargolearn-enteros
Tipos Decimales (punto flotante): https://tinyurl.com/cargolearn-decimales
Tipo Car√°cter: https://tinyurl.com/cargolearn-caracteres
Tipo String Slice (&str): https://tinyurl.com/cargolearn-str

C√≥digo fuente presentaci√≥n: https://tinyurl.com/cargolearn-repo

Mi p√°gina web: https://garriga.dev

Notas:
He adaptado los mensajes de error del compilador de Rust para que solamente muestren la informaci√≥n necesaria para el v√≠deo, as√≠ como traducido del ingl√©s al castellano.

El compilador es muy amigable, pero para un principiante puede llegar a ser un poco abrumador.

Poco a poco ir√© haciendo la transici√≥n a los errores originales.